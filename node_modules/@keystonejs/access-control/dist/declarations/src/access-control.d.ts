declare type Static = boolean;
declare type Declarative = Record<string, any>;
declare type Imperative<T> = (args: T) => Promise<Static | Declarative>;
declare type FieldImperative<T> = (args: T) => Promise<Static>;
declare type Context = any;
declare type ListAccessArgs = {
    operation: keyof ListAccess<ListAccessArgs>;
    listKey: string;
    authentication: any;
    gqlName: string;
    context: Context;
    originalInput?: any;
    itemId?: any;
    itemIds?: any;
};
declare type FieldAccessArgs = {
    operation: keyof FieldAccess<FieldAccessArgs>;
    listKey: string;
    fieldKey: string;
    originalInput: any;
    existingItem: any;
    authentication: any;
    gqlName: string;
    itemId: any;
    itemIds: any;
    context: Context;
};
declare type AuthAccessArgs = {
    operation: keyof AuthAccess<AuthAccessArgs>;
    listKey: string;
    authentication: any;
    gqlName: string;
    context: Context;
};
declare type CustomAccessArgs = {
    item: any;
    args: any;
    context: Context;
    info: any;
    authentication: any;
    gqlName: string;
};
declare type ListAccess<Args> = {
    create: Static | Declarative | Imperative<Args>;
    read: Static | Declarative | Imperative<Args>;
    update: Static | Declarative | Imperative<Args>;
    delete: Static | Declarative | Imperative<Args>;
};
declare type AuthAccess<Args> = {
    auth: Static | Declarative | Imperative<Args>;
};
declare type FieldAccess<Args> = {
    create: Static | FieldImperative<Args>;
    read: Static | FieldImperative<Args>;
    update: Static | FieldImperative<Args>;
};
declare type CustomAccess<Args> = Static | Declarative | Imperative<Args>;
export declare function parseCustomAccess<SN extends string, Args>({ defaultAccess, access, schemaNames, }: {
    defaultAccess: CustomAccess<Args>;
    access?: Partial<Record<SN, CustomAccess<Args>>> | CustomAccess<Args>;
    schemaNames: SN[];
}): Record<SN, CustomAccess<Args>> & {
    internal: true;
};
declare type ListAuthAccess<Args> = ListAccess<Args> & AuthAccess<Args>;
export declare function parseListAccess<SN extends string, Args>({ listKey, defaultAccess, access, schemaNames, }: {
    listKey: string;
    defaultAccess: ListAccess<Args>['read'];
    access?: Partial<Record<SN, Partial<ListAuthAccess<Args>> | ListAccess<Args>['read']>> | Partial<ListAuthAccess<Args>> | ListAccess<Args>['read'];
    schemaNames: SN[];
}): Record<SN, ListAuthAccess<Args>> & {
    internal: Record<"create" | "read" | "update" | "delete" | "auth", true>;
};
export declare function parseFieldAccess<SN extends string, Args>({ listKey, fieldKey, defaultAccess, access, schemaNames, }: {
    listKey: string;
    fieldKey: string;
    defaultAccess: FieldAccess<Args>['read'];
    access?: Partial<Record<SN, Partial<FieldAccess<Args>> | FieldAccess<Args>['read']>> | Partial<FieldAccess<Args>> | FieldAccess<Args>['read'];
    schemaNames: SN[];
}): Record<SN, FieldAccess<Args>> & {
    internal: Record<"create" | "read" | "update", true>;
};
export declare function validateCustomAccessControl({ item, args, context, info, access, authentication, gqlName, }: {
    access: CustomAccess<CustomAccessArgs>;
} & CustomAccessArgs): Promise<boolean | Record<string, any>>;
export declare function validateListAccessControl({ access, listKey, operation, authentication, originalInput, gqlName, itemId, itemIds, context, }: {
    access: ListAccess<ListAccessArgs>;
} & ListAccessArgs): Promise<boolean | Record<string, any>>;
export declare function validateFieldAccessControl({ access, listKey, fieldKey, originalInput, existingItem, operation, authentication, gqlName, itemId, itemIds, context, }: {
    access: FieldAccess<FieldAccessArgs>;
} & FieldAccessArgs): Promise<boolean>;
export declare function validateAuthAccessControl({ access, listKey, authentication, gqlName, context, }: {
    access: AuthAccess<AuthAccessArgs>;
} & Omit<AuthAccessArgs, 'operation'>): Promise<boolean | Record<string, any>>;
export {};
