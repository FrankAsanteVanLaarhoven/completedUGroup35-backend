/// <reference types="node" />
import { IncomingMessage, ServerResponse } from 'http';
import { GraphQLSchema, ExecutionResult, DocumentNode } from 'graphql';
import type { BaseGeneratedListTypes, GqlNames, MaybePromise } from './utils';
import { BaseKeystone } from './base';
export declare type DatabaseAPIs = {
    knex?: any;
    mongoose?: any;
    prisma?: any;
};
declare type FieldDefaultValueArgs<T> = {
    context: KeystoneContext;
    originalInput?: T;
};
export declare type FieldDefaultValue<T> = T | null | MaybePromise<(args: FieldDefaultValueArgs<T>) => T | null | undefined>;
export declare type CreateContext = (args: {
    sessionContext?: SessionContext<any>;
    skipAccessControl?: boolean;
    req?: IncomingMessage;
}) => KeystoneContext;
export declare type SessionImplementation = {
    createSessionContext(req: IncomingMessage, res: ServerResponse, createContext: CreateContext): Promise<SessionContext<any>>;
};
export declare type AccessControlContext = {
    getListAccessControlForUser: any;
    getFieldAccessControlForUser: any;
};
export declare type SessionContext<T> = {
    session?: {
        itemId: string;
        listKey: string;
        data?: Record<string, any>;
    } | any;
    startSession(data: T): Promise<string>;
    endSession(): Promise<void>;
};
export declare type KeystoneContext = {
    schemaName: 'public';
    lists: KeystoneListsAPI<any>;
    totalResults: number;
    keystone: BaseKeystone;
    graphql: KeystoneGraphQLAPI<any>;
    /** @deprecated */
    executeGraphQL: any;
    /** @deprecated */
    gqlNames: (listKey: string) => Record<string, string>;
    maxTotalResults: number;
    createContext: CreateContext;
    req?: IncomingMessage;
} & AccessControlContext & Partial<SessionContext<any>> & DatabaseAPIs;
export declare type GraphQLResolver = (root: any, args: any, context: KeystoneContext) => any;
export declare type GraphQLSchemaExtension = {
    typeDefs: string;
    resolvers: Record<string, Record<string, GraphQLResolver>>;
};
declare type GraphQLExecutionArguments = {
    context?: any;
    query: string | DocumentNode;
    variables: Record<string, any>;
};
export declare type KeystoneGraphQLAPI<KeystoneListsTypeInfo extends Record<string, BaseGeneratedListTypes>> = {
    createContext: CreateContext;
    schema: GraphQLSchema;
    run: (args: GraphQLExecutionArguments) => Promise<Record<string, any>>;
    raw: (args: GraphQLExecutionArguments) => Promise<ExecutionResult>;
};
declare type ResolveFields = {
    readonly resolveFields?: false | string;
};
export declare type KeystoneListsAPI<KeystoneListsTypeInfo extends Record<string, BaseGeneratedListTypes>> = {
    [Key in keyof KeystoneListsTypeInfo]: {
        findMany(args: KeystoneListsTypeInfo[Key]['args']['listQuery'] & ResolveFields): Promise<readonly KeystoneListsTypeInfo[Key]['backing'][]>;
        findOne(args: {
            readonly where: {
                readonly id: string;
            };
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        count(args: KeystoneListsTypeInfo[Key]['args']['listQuery']): Promise<number>;
        updateOne(args: {
            readonly id: string;
            readonly data: KeystoneListsTypeInfo[Key]['inputs']['update'];
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        updateMany(args: {
            readonly data: readonly {
                readonly id: string;
                readonly data: KeystoneListsTypeInfo[Key]['inputs']['update'];
            }[];
        } & ResolveFields): Promise<(KeystoneListsTypeInfo[Key]['backing'] | null)[] | null>;
        createOne(args: {
            readonly data: KeystoneListsTypeInfo[Key]['inputs']['create'];
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        createMany(args: {
            readonly data: readonly {
                readonly data: KeystoneListsTypeInfo[Key]['inputs']['update'];
            }[];
        } & ResolveFields): Promise<(KeystoneListsTypeInfo[Key]['backing'] | null)[] | null>;
        deleteOne(args: {
            readonly id: string;
        } & ResolveFields): Promise<KeystoneListsTypeInfo[Key]['backing'] | null>;
        deleteMany(args: {
            readonly ids: readonly string[];
        } & ResolveFields): Promise<(KeystoneListsTypeInfo[Key]['backing'] | null)[] | null>;
    };
};
export declare function getGqlNames({ listKey, itemQueryName: _itemQueryName, listQueryName: _listQueryName, }: {
    listKey: string;
    itemQueryName: string;
    listQueryName: string;
}): GqlNames;
export {};
